/**
 * $Id: sh4x86.in,v 1.9 2007-09-13 08:28:01 nkeynes Exp $
 * 
 * SH4 => x86 translation. This version does no real optimization, it just
 * outputs straight-line x86 code - it mainly exists to provide a baseline
 * to test the optimizing versions against.
 *
 * Copyright (c) 2007 Nathan Keynes.
 *
 * This program is free software; you can redistribute it and/or modify
 * it under the terms of the GNU General Public License as published by
 * the Free Software Foundation; either version 2 of the License, or
 * (at your option) any later version.
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU General Public License for more details.
 */

#include <assert.h>

#ifndef NDEBUG
#define DEBUG_JUMPS 1
#endif

#include "sh4/sh4core.h"
#include "sh4/sh4trans.h"
#include "sh4/x86op.h"
#include "clock.h"

#define DEFAULT_BACKPATCH_SIZE 4096

/** 
 * Struct to manage internal translation state. This state is not saved -
 * it is only valid between calls to sh4_translate_begin_block() and
 * sh4_translate_end_block()
 */
struct sh4_x86_state {
    gboolean in_delay_slot;
    gboolean priv_checked; /* true if we've already checked the cpu mode. */
    gboolean fpuen_checked; /* true if we've already checked fpu enabled. */

    /* Allocated memory for the (block-wide) back-patch list */
    uint32_t **backpatch_list;
    uint32_t backpatch_posn;
    uint32_t backpatch_size;
};

#define EXIT_DATA_ADDR_READ 0
#define EXIT_DATA_ADDR_WRITE 7
#define EXIT_ILLEGAL 14
#define EXIT_SLOT_ILLEGAL 21
#define EXIT_FPU_DISABLED 28
#define EXIT_SLOT_FPU_DISABLED 35

static struct sh4_x86_state sh4_x86;

void sh4_x86_init()
{
    sh4_x86.backpatch_list = malloc(DEFAULT_BACKPATCH_SIZE);
    sh4_x86.backpatch_size = DEFAULT_BACKPATCH_SIZE / sizeof(uint32_t *);
}


static void sh4_x86_add_backpatch( uint8_t *ptr )
{
    if( sh4_x86.backpatch_posn == sh4_x86.backpatch_size ) {
	sh4_x86.backpatch_size <<= 1;
	sh4_x86.backpatch_list = realloc( sh4_x86.backpatch_list, sh4_x86.backpatch_size * sizeof(uint32_t *) );
	assert( sh4_x86.backpatch_list != NULL );
    }
    sh4_x86.backpatch_list[sh4_x86.backpatch_posn++] = (uint32_t *)ptr;
}

static void sh4_x86_do_backpatch( uint8_t *reloc_base )
{
    unsigned int i;
    for( i=0; i<sh4_x86.backpatch_posn; i++ ) {
	*sh4_x86.backpatch_list[i] += (reloc_base - ((uint8_t *)sh4_x86.backpatch_list[i]) - 4);
    }
}

/**
 * Emit an instruction to load an SH4 reg into a real register
 */
static inline void load_reg( int x86reg, int sh4reg ) 
{
    /* mov [bp+n], reg */
    OP(0x8B);
    OP(0x45 + (x86reg<<3));
    OP(REG_OFFSET(r[sh4reg]));
}

static inline void load_reg16s( int x86reg, int sh4reg )
{
    OP(0x0F);
    OP(0xBF);
    MODRM_r32_sh4r(x86reg, REG_OFFSET(r[sh4reg]));
}

static inline void load_reg16u( int x86reg, int sh4reg )
{
    OP(0x0F);
    OP(0xB7);
    MODRM_r32_sh4r(x86reg, REG_OFFSET(r[sh4reg]));

}

#define load_spreg( x86reg, regoff ) MOV_sh4r_r32( regoff, x86reg )
#define store_spreg( x86reg, regoff ) MOV_r32_sh4r( x86reg, regoff )
/**
 * Emit an instruction to load an immediate value into a register
 */
static inline void load_imm32( int x86reg, uint32_t value ) {
    /* mov #value, reg */
    OP(0xB8 + x86reg);
    OP32(value);
}

/**
 * Emit an instruction to store an SH4 reg (RN)
 */
void static inline store_reg( int x86reg, int sh4reg ) {
    /* mov reg, [bp+n] */
    OP(0x89);
    OP(0x45 + (x86reg<<3));
    OP(REG_OFFSET(r[sh4reg]));
}

#define load_fr_bank(bankreg) load_spreg( bankreg, REG_OFFSET(fr_bank))

/**
 * Load an FR register (single-precision floating point) into an integer x86
 * register (eg for register-to-register moves)
 */
void static inline load_fr( int bankreg, int x86reg, int frm )
{
    OP(0x8B); OP(0x40+bankreg+(x86reg<<3)); OP((frm^1)<<2);
}

/**
 * Store an FR register (single-precision floating point) into an integer x86
 * register (eg for register-to-register moves)
 */
void static inline store_fr( int bankreg, int x86reg, int frn )
{
    OP(0x89);  OP(0x40+bankreg+(x86reg<<3)); OP((frn^1)<<2);
}


/**
 * Load a pointer to the back fp back into the specified x86 register. The
 * bankreg must have been previously loaded with FPSCR.
 * NB: 10 bytes
 */
static inline void load_xf_bank( int bankreg )
{
    SHR_imm8_r32( (21 - 6), bankreg ); // Extract bit 21 then *64 for bank size
    AND_imm8s_r32( 0x40, bankreg );    // Complete extraction
    OP(0x8D); OP(0x44+(bankreg<<3)); OP(0x28+bankreg); OP(REG_OFFSET(fr)); // LEA [ebp+bankreg+disp], bankreg
}

/**
 * Push FPUL (as a 32-bit float) onto the FPU stack
 */
static inline void push_fpul( )
{
    OP(0xD9); OP(0x45); OP(R_FPUL);
}

/**
 * Pop FPUL (as a 32-bit float) from the FPU stack
 */
static inline void pop_fpul( )
{
    OP(0xD9); OP(0x5D); OP(R_FPUL);
}

/**
 * Push a 32-bit float onto the FPU stack, with bankreg previously loaded
 * with the location of the current fp bank.
 */
static inline void push_fr( int bankreg, int frm ) 
{
    OP(0xD9); OP(0x40 + bankreg); OP((frm^1)<<2);  // FLD.S [bankreg + frm^1*4]
}

/**
 * Pop a 32-bit float from the FPU stack and store it back into the fp bank, 
 * with bankreg previously loaded with the location of the current fp bank.
 */
static inline void pop_fr( int bankreg, int frm )
{
    OP(0xD9); OP(0x58 + bankreg); OP((frm^1)<<2); // FST.S [bankreg + frm^1*4]
}

/**
 * Push a 64-bit double onto the FPU stack, with bankreg previously loaded
 * with the location of the current fp bank.
 */
static inline void push_dr( int bankreg, int frm )
{
    OP(0xDD); OP(0x40 + bankreg); OP(frm<<2); // FLD.D [bankreg + frm*4]
}

static inline void pop_dr( int bankreg, int frm )
{
    OP(0xDD); OP(0x58 + bankreg); OP(frm<<2); // FST.D [bankreg + frm*4]
}

/**
 * Note: clobbers EAX to make the indirect call - this isn't usually
 * a problem since the callee will usually clobber it anyway.
 */
static inline void call_func0( void *ptr )
{
    load_imm32(R_EAX, (uint32_t)ptr);
    CALL_r32(R_EAX);
}

static inline void call_func1( void *ptr, int arg1 )
{
    PUSH_r32(arg1);
    call_func0(ptr);
    ADD_imm8s_r32( 4, R_ESP );
}

static inline void call_func2( void *ptr, int arg1, int arg2 )
{
    PUSH_r32(arg2);
    PUSH_r32(arg1);
    call_func0(ptr);
    ADD_imm8s_r32( 8, R_ESP );
}

/**
 * Write a double (64-bit) value into memory, with the first word in arg2a, and
 * the second in arg2b
 * NB: 30 bytes
 */
static inline void MEM_WRITE_DOUBLE( int addr, int arg2a, int arg2b )
{
    ADD_imm8s_r32( 4, addr );
    PUSH_r32(addr);
    PUSH_r32(arg2b);
    ADD_imm8s_r32( -4, addr );
    PUSH_r32(addr);
    PUSH_r32(arg2a);
    call_func0(sh4_write_long);
    ADD_imm8s_r32( 8, R_ESP );
    call_func0(sh4_write_long);
    ADD_imm8s_r32( 8, R_ESP );
}

/**
 * Read a double (64-bit) value from memory, writing the first word into arg2a
 * and the second into arg2b. The addr must not be in EAX
 * NB: 27 bytes
 */
static inline void MEM_READ_DOUBLE( int addr, int arg2a, int arg2b )
{
    PUSH_r32(addr);
    call_func0(sh4_read_long);
    POP_r32(addr);
    PUSH_r32(R_EAX);
    ADD_imm8s_r32( 4, addr );
    PUSH_r32(addr);
    call_func0(sh4_read_long);
    ADD_imm8s_r32( 4, R_ESP );
    MOV_r32_r32( R_EAX, arg2b );
    POP_r32(arg2a);
}

/* Exception checks - Note that all exception checks will clobber EAX */
static void check_priv( )
{
    if( !sh4_x86.priv_checked ) {
	sh4_x86.priv_checked = TRUE;
	load_spreg( R_EAX, R_SR );
	AND_imm32_r32( SR_MD, R_EAX );
	if( sh4_x86.in_delay_slot ) {
	    JE_exit( EXIT_SLOT_ILLEGAL );
	} else {
	    JE_exit( EXIT_ILLEGAL );
	}
    }
}

static void check_fpuen( )
{
    if( !sh4_x86.fpuen_checked ) {
	sh4_x86.fpuen_checked = TRUE;
	load_spreg( R_EAX, R_SR );
	AND_imm32_r32( SR_FD, R_EAX );
	if( sh4_x86.in_delay_slot ) {
	    JNE_exit(EXIT_SLOT_FPU_DISABLED);
	} else {
	    JNE_exit(EXIT_FPU_DISABLED);
	}
    }
}

static void check_ralign16( int x86reg )
{
    TEST_imm32_r32( 0x00000001, x86reg );
    JNE_exit(EXIT_DATA_ADDR_READ);
}

static void check_walign16( int x86reg )
{
    TEST_imm32_r32( 0x00000001, x86reg );
    JNE_exit(EXIT_DATA_ADDR_WRITE);
}

static void check_ralign32( int x86reg )
{
    TEST_imm32_r32( 0x00000003, x86reg );
    JNE_exit(EXIT_DATA_ADDR_READ);
}
static void check_walign32( int x86reg )
{
    TEST_imm32_r32( 0x00000003, x86reg );
    JNE_exit(EXIT_DATA_ADDR_WRITE);
}


#define UNDEF()
#define MEM_RESULT(value_reg) if(value_reg != R_EAX) { MOV_r32_r32(R_EAX,value_reg); }
#define MEM_READ_BYTE( addr_reg, value_reg ) call_func1(sh4_read_byte, addr_reg ); MEM_RESULT(value_reg)
#define MEM_READ_WORD( addr_reg, value_reg ) call_func1(sh4_read_word, addr_reg ); MEM_RESULT(value_reg)
#define MEM_READ_LONG( addr_reg, value_reg ) call_func1(sh4_read_long, addr_reg ); MEM_RESULT(value_reg)
#define MEM_WRITE_BYTE( addr_reg, value_reg ) call_func2(sh4_write_byte, addr_reg, value_reg)
#define MEM_WRITE_WORD( addr_reg, value_reg ) call_func2(sh4_write_word, addr_reg, value_reg)
#define MEM_WRITE_LONG( addr_reg, value_reg ) call_func2(sh4_write_long, addr_reg, value_reg)

#define RAISE_EXCEPTION( exc ) call_func1(sh4_raise_exception, exc);
#define SLOTILLEGAL() RAISE_EXCEPTION(EXC_SLOT_ILLEGAL); sh4_x86.in_delay_slot = FALSE; return 1



/**
 * Emit the 'start of block' assembly. Sets up the stack frame and save
 * SI/DI as required
 */
void sh4_translate_begin_block() 
{
    PUSH_r32(R_EBP);
    /* mov &sh4r, ebp */
    load_imm32( R_EBP, (uint32_t)&sh4r );
    PUSH_r32(R_EDI);
    PUSH_r32(R_ESI);
    XOR_r32_r32(R_ESI, R_ESI);
    
    sh4_x86.in_delay_slot = FALSE;
    sh4_x86.priv_checked = FALSE;
    sh4_x86.fpuen_checked = FALSE;
    sh4_x86.backpatch_posn = 0;
}

/**
 * Exit the block early (ie branch out), conditionally or otherwise
 */
void exit_block( )
{
    store_spreg( R_EDI, REG_OFFSET(pc) );
    MOV_moff32_EAX( (uint32_t)&sh4_cpu_period );
    load_spreg( R_ECX, REG_OFFSET(slice_cycle) );
    MUL_r32( R_ESI );
    ADD_r32_r32( R_EAX, R_ECX );
    store_spreg( R_ECX, REG_OFFSET(slice_cycle) );
    load_imm32( R_EAX, 1 );
    POP_r32(R_ESI);
    POP_r32(R_EDI);
    POP_r32(R_EBP);
    RET();
}

/**
 * Flush any open regs back to memory, restore SI/DI/, update PC, etc
 */
void sh4_translate_end_block( sh4addr_t pc ) {
    assert( !sh4_x86.in_delay_slot ); // should never stop here
    // Normal termination - save PC, cycle count
    exit_block( );

    uint8_t *end_ptr = xlat_output;
    // Exception termination. Jump block for various exception codes:
    PUSH_imm32( EXC_DATA_ADDR_READ );
    JMP_rel8( 33, target1 );
    PUSH_imm32( EXC_DATA_ADDR_WRITE );
    JMP_rel8( 26, target2 );
    PUSH_imm32( EXC_ILLEGAL );
    JMP_rel8( 19, target3 );
    PUSH_imm32( EXC_SLOT_ILLEGAL ); 
    JMP_rel8( 12, target4 );
    PUSH_imm32( EXC_FPU_DISABLED ); 
    JMP_rel8( 5, target5 );
    PUSH_imm32( EXC_SLOT_FPU_DISABLED );
    // target
    JMP_TARGET(target1);
    JMP_TARGET(target2);
    JMP_TARGET(target3);
    JMP_TARGET(target4);
    JMP_TARGET(target5);
    load_spreg( R_ECX, REG_OFFSET(pc) );
    ADD_r32_r32( R_ESI, R_ECX );
    ADD_r32_r32( R_ESI, R_ECX );
    store_spreg( R_ECX, REG_OFFSET(pc) );
    MOV_moff32_EAX( (uint32_t)&sh4_cpu_period );
    load_spreg( R_ECX, REG_OFFSET(slice_cycle) );
    MUL_r32( R_ESI );
    ADD_r32_r32( R_EAX, R_ECX );
    store_spreg( R_ECX, REG_OFFSET(slice_cycle) );

    load_imm32( R_EAX, (uint32_t)sh4_raise_exception ); // 6
    CALL_r32( R_EAX ); // 2
    ADD_imm8s_r32( 4, R_ESP );
    POP_r32(R_ESI);
    POP_r32(R_EDI);
    POP_r32(R_EBP);
    RET();

    sh4_x86_do_backpatch( end_ptr );
}

/**
 * Translate a single instruction. Delayed branches are handled specially
 * by translating both branch and delayed instruction as a single unit (as
 * 
 *
 * @return true if the instruction marks the end of a basic block
 * (eg a branch or 
 */
uint32_t sh4_x86_translate_instruction( uint32_t pc )
{
    uint16_t ir = sh4_read_word( pc );
    
%%
/* ALU operations */
ADD Rm, Rn {:
    load_reg( R_EAX, Rm );
    load_reg( R_ECX, Rn );
    ADD_r32_r32( R_EAX, R_ECX );
    store_reg( R_ECX, Rn );
:}
ADD #imm, Rn {:  
    load_reg( R_EAX, Rn );
    ADD_imm8s_r32( imm, R_EAX );
    store_reg( R_EAX, Rn );
:}
ADDC Rm, Rn {:
    load_reg( R_EAX, Rm );
    load_reg( R_ECX, Rn );
    LDC_t();
    ADC_r32_r32( R_EAX, R_ECX );
    store_reg( R_ECX, Rn );
    SETC_t();
:}
ADDV Rm, Rn {:
    load_reg( R_EAX, Rm );
    load_reg( R_ECX, Rn );
    ADD_r32_r32( R_EAX, R_ECX );
    store_reg( R_ECX, Rn );
    SETO_t();
:}
AND Rm, Rn {:
    load_reg( R_EAX, Rm );
    load_reg( R_ECX, Rn );
    AND_r32_r32( R_EAX, R_ECX );
    store_reg( R_ECX, Rn );
:}
AND #imm, R0 {:  
    load_reg( R_EAX, 0 );
    AND_imm32_r32(imm, R_EAX); 
    store_reg( R_EAX, 0 );
:}
AND.B #imm, @(R0, GBR) {: 
    load_reg( R_EAX, 0 );
    load_spreg( R_ECX, R_GBR );
    ADD_r32_r32( R_EAX, R_ECX );
    MEM_READ_BYTE( R_ECX, R_EAX );
    AND_imm32_r32(imm, R_ECX );
    MEM_WRITE_BYTE( R_ECX, R_EAX );
:}
CMP/EQ Rm, Rn {:  
    load_reg( R_EAX, Rm );
    load_reg( R_ECX, Rn );
    CMP_r32_r32( R_EAX, R_ECX );
    SETE_t();
:}
CMP/EQ #imm, R0 {:  
    load_reg( R_EAX, 0 );
    CMP_imm8s_r32(imm, R_EAX);
    SETE_t();
:}
CMP/GE Rm, Rn {:  
    load_reg( R_EAX, Rm );
    load_reg( R_ECX, Rn );
    CMP_r32_r32( R_EAX, R_ECX );
    SETGE_t();
:}
CMP/GT Rm, Rn {: 
    load_reg( R_EAX, Rm );
    load_reg( R_ECX, Rn );
    CMP_r32_r32( R_EAX, R_ECX );
    SETG_t();
:}
CMP/HI Rm, Rn {:  
    load_reg( R_EAX, Rm );
    load_reg( R_ECX, Rn );
    CMP_r32_r32( R_EAX, R_ECX );
    SETA_t();
:}
CMP/HS Rm, Rn {: 
    load_reg( R_EAX, Rm );
    load_reg( R_ECX, Rn );
    CMP_r32_r32( R_EAX, R_ECX );
    SETAE_t();
 :}
CMP/PL Rn {: 
    load_reg( R_EAX, Rn );
    CMP_imm8s_r32( 0, R_EAX );
    SETG_t();
:}
CMP/PZ Rn {:  
    load_reg( R_EAX, Rn );
    CMP_imm8s_r32( 0, R_EAX );
    SETGE_t();
:}
CMP/STR Rm, Rn {:  
    load_reg( R_EAX, Rm );
    load_reg( R_ECX, Rn );
    XOR_r32_r32( R_ECX, R_EAX );
    TEST_r8_r8( R_AL, R_AL );
    JE_rel8(13, target1);
    TEST_r8_r8( R_AH, R_AH ); // 2
    JE_rel8(9, target2);
    SHR_imm8_r32( 16, R_EAX ); // 3
    TEST_r8_r8( R_AL, R_AL ); // 2
    JE_rel8(2, target3);
    TEST_r8_r8( R_AH, R_AH ); // 2
    JMP_TARGET(target1);
    JMP_TARGET(target2);
    JMP_TARGET(target3);
    SETE_t();
:}
DIV0S Rm, Rn {:
    load_reg( R_EAX, Rm );
    load_reg( R_ECX, Rm );
    SHR_imm8_r32( 31, R_EAX );
    SHR_imm8_r32( 31, R_ECX );
    store_spreg( R_EAX, R_M );
    store_spreg( R_ECX, R_Q );
    CMP_r32_r32( R_EAX, R_ECX );
    SETE_t();
:}
DIV0U {:  
    XOR_r32_r32( R_EAX, R_EAX );
    store_spreg( R_EAX, R_Q );
    store_spreg( R_EAX, R_M );
    store_spreg( R_EAX, R_T );
:}
DIV1 Rm, Rn {:  
    load_reg( R_ECX, Rn );
    LDC_t();
    RCL1_r32( R_ECX ); // OP2
    SETC_r32( R_EDX ); // Q
    load_spreg( R_EAX, R_Q );
    CMP_sh4r_r32( R_M, R_EAX );
    JE_rel8(8,mqequal);
    ADD_sh4r_r32( REG_OFFSET(r[Rm]), R_ECX );
    JMP_rel8(3, mqnotequal);
    JMP_TARGET(mqequal);
    SUB_sh4r_r32( REG_OFFSET(r[Rm]), R_ECX );
    JMP_TARGET(mqnotequal);
    // TODO
:}
DMULS.L Rm, Rn {:  
    load_reg( R_EAX, Rm );
    load_reg( R_ECX, Rn );
    IMUL_r32(R_ECX);
    store_spreg( R_EDX, R_MACH );
    store_spreg( R_EAX, R_MACL );
:}
DMULU.L Rm, Rn {:  
    load_reg( R_EAX, Rm );
    load_reg( R_ECX, Rn );
    MUL_r32(R_ECX);
    store_spreg( R_EDX, R_MACH );
    store_spreg( R_EAX, R_MACL );    
:}
DT Rn {:  
    load_reg( R_EAX, Rn );
    ADD_imm8s_r32( -1, R_EAX );
    store_reg( R_EAX, Rn );
    SETE_t();
:}
EXTS.B Rm, Rn {:  
    load_reg( R_EAX, Rm );
    MOVSX_r8_r32( R_EAX, R_EAX );
    store_reg( R_EAX, Rn );
:}
EXTS.W Rm, Rn {:  
    load_reg( R_EAX, Rm );
    MOVSX_r16_r32( R_EAX, R_EAX );
    store_reg( R_EAX, Rn );
:}
EXTU.B Rm, Rn {:  
    load_reg( R_EAX, Rm );
    MOVZX_r8_r32( R_EAX, R_EAX );
    store_reg( R_EAX, Rn );
:}
EXTU.W Rm, Rn {:  
    load_reg( R_EAX, Rm );
    MOVZX_r16_r32( R_EAX, R_EAX );
    store_reg( R_EAX, Rn );
:}
MAC.L @Rm+, @Rn+ {:  :}
MAC.W @Rm+, @Rn+ {:  :}
MOVT Rn {:  
    load_spreg( R_EAX, R_T );
    store_reg( R_EAX, Rn );
:}
MUL.L Rm, Rn {:  
    load_reg( R_EAX, Rm );
    load_reg( R_ECX, Rn );
    MUL_r32( R_ECX );
    store_spreg( R_EAX, R_MACL );
:}
MULS.W Rm, Rn {:
    load_reg16s( R_EAX, Rm );
    load_reg16s( R_ECX, Rn );
    MUL_r32( R_ECX );
    store_spreg( R_EAX, R_MACL );
:}
MULU.W Rm, Rn {:  
    load_reg16u( R_EAX, Rm );
    load_reg16u( R_ECX, Rn );
    MUL_r32( R_ECX );
    store_spreg( R_EAX, R_MACL );
:}
NEG Rm, Rn {:
    load_reg( R_EAX, Rm );
    NEG_r32( R_EAX );
    store_reg( R_EAX, Rn );
:}
NEGC Rm, Rn {:  
    load_reg( R_EAX, Rm );
    XOR_r32_r32( R_ECX, R_ECX );
    LDC_t();
    SBB_r32_r32( R_EAX, R_ECX );
    store_reg( R_ECX, Rn );
    SETC_t();
:}
NOT Rm, Rn {:  
    load_reg( R_EAX, Rm );
    NOT_r32( R_EAX );
    store_reg( R_EAX, Rn );
:}
OR Rm, Rn {:  
    load_reg( R_EAX, Rm );
    load_reg( R_ECX, Rn );
    OR_r32_r32( R_EAX, R_ECX );
    store_reg( R_ECX, Rn );
:}
OR #imm, R0 {:
    load_reg( R_EAX, 0 );
    OR_imm32_r32(imm, R_EAX);
    store_reg( R_EAX, 0 );
:}
OR.B #imm, @(R0, GBR) {:  
    load_reg( R_EAX, 0 );
    load_spreg( R_ECX, R_GBR );
    ADD_r32_r32( R_EAX, R_ECX );
    MEM_READ_BYTE( R_ECX, R_EAX );
    OR_imm32_r32(imm, R_ECX );
    MEM_WRITE_BYTE( R_ECX, R_EAX );
:}
ROTCL Rn {:
    load_reg( R_EAX, Rn );
    LDC_t();
    RCL1_r32( R_EAX );
    store_reg( R_EAX, Rn );
    SETC_t();
:}
ROTCR Rn {:  
    load_reg( R_EAX, Rn );
    LDC_t();
    RCR1_r32( R_EAX );
    store_reg( R_EAX, Rn );
    SETC_t();
:}
ROTL Rn {:  
    load_reg( R_EAX, Rn );
    ROL1_r32( R_EAX );
    store_reg( R_EAX, Rn );
    SETC_t();
:}
ROTR Rn {:  
    load_reg( R_EAX, Rn );
    ROR1_r32( R_EAX );
    store_reg( R_EAX, Rn );
    SETC_t();
:}
SHAD Rm, Rn {:
    /* Annoyingly enough, not directly convertible */
    load_reg( R_EAX, Rn );
    load_reg( R_ECX, Rm );
    CMP_imm32_r32( 0, R_ECX );
    JGE_rel8(9, doshl);
                    
    NEG_r32( R_ECX );      // 2
    AND_imm8_r8( 0x1F, R_CL ); // 3
    SAR_r32_CL( R_EAX );       // 2
    JMP_rel8(5, end);          // 2

    JMP_TARGET(doshl);
    AND_imm8_r8( 0x1F, R_CL ); // 3
    SHL_r32_CL( R_EAX );       // 2
    JMP_TARGET(end);
    store_reg( R_EAX, Rn );
:}
SHLD Rm, Rn {:  
    load_reg( R_EAX, Rn );
    load_reg( R_ECX, Rm );
    CMP_imm32_r32( 0, R_ECX );
    JGE_rel8(9, doshl);

    NEG_r32( R_ECX );      // 2
    AND_imm8_r8( 0x1F, R_CL ); // 3
    SHR_r32_CL( R_EAX );       // 2
    JMP_rel8(5, end);          // 2

    JMP_TARGET(doshl);
    AND_imm8_r8( 0x1F, R_CL ); // 3
    SHL_r32_CL( R_EAX );       // 2
    JMP_TARGET(end);
    store_reg( R_EAX, Rn );
:}
SHAL Rn {: 
    load_reg( R_EAX, Rn );
    SHL1_r32( R_EAX );
    store_reg( R_EAX, Rn );
:}
SHAR Rn {:  
    load_reg( R_EAX, Rn );
    SAR1_r32( R_EAX );
    store_reg( R_EAX, Rn );
:}
SHLL Rn {:  
    load_reg( R_EAX, Rn );
    SHL1_r32( R_EAX );
    store_reg( R_EAX, Rn );
:}
SHLL2 Rn {:
    load_reg( R_EAX, Rn );
    SHL_imm8_r32( 2, R_EAX );
    store_reg( R_EAX, Rn );
:}
SHLL8 Rn {:  
    load_reg( R_EAX, Rn );
    SHL_imm8_r32( 8, R_EAX );
    store_reg( R_EAX, Rn );
:}
SHLL16 Rn {:  
    load_reg( R_EAX, Rn );
    SHL_imm8_r32( 16, R_EAX );
    store_reg( R_EAX, Rn );
:}
SHLR Rn {:  
    load_reg( R_EAX, Rn );
    SHR1_r32( R_EAX );
    store_reg( R_EAX, Rn );
:}
SHLR2 Rn {:  
    load_reg( R_EAX, Rn );
    SHR_imm8_r32( 2, R_EAX );
    store_reg( R_EAX, Rn );
:}
SHLR8 Rn {:  
    load_reg( R_EAX, Rn );
    SHR_imm8_r32( 8, R_EAX );
    store_reg( R_EAX, Rn );
:}
SHLR16 Rn {:  
    load_reg( R_EAX, Rn );
    SHR_imm8_r32( 16, R_EAX );
    store_reg( R_EAX, Rn );
:}
SUB Rm, Rn {:  
    load_reg( R_EAX, Rm );
    load_reg( R_ECX, Rn );
    SUB_r32_r32( R_EAX, R_ECX );
    store_reg( R_ECX, Rn );
:}
SUBC Rm, Rn {:  
    load_reg( R_EAX, Rm );
    load_reg( R_ECX, Rn );
    LDC_t();
    SBB_r32_r32( R_EAX, R_ECX );
    store_reg( R_ECX, Rn );
:}
SUBV Rm, Rn {:  
    load_reg( R_EAX, Rm );
    load_reg( R_ECX, Rn );
    SUB_r32_r32( R_EAX, R_ECX );
    store_reg( R_ECX, Rn );
    SETO_t();
:}
SWAP.B Rm, Rn {:  
    load_reg( R_EAX, Rm );
    XCHG_r8_r8( R_AL, R_AH );
    store_reg( R_EAX, Rn );
:}
SWAP.W Rm, Rn {:  
    load_reg( R_EAX, Rm );
    MOV_r32_r32( R_EAX, R_ECX );
    SHL_imm8_r32( 16, R_ECX );
    SHR_imm8_r32( 16, R_EAX );
    OR_r32_r32( R_EAX, R_ECX );
    store_reg( R_ECX, Rn );
:}
TAS.B @Rn {:  
    load_reg( R_ECX, Rn );
    MEM_READ_BYTE( R_ECX, R_EAX );
    TEST_r8_r8( R_AL, R_AL );
    SETE_t();
    OR_imm8_r8( 0x80, R_AL );
    MEM_WRITE_BYTE( R_ECX, R_EAX );
:}
TST Rm, Rn {:  
    load_reg( R_EAX, Rm );
    load_reg( R_ECX, Rn );
    TEST_r32_r32( R_EAX, R_ECX );
    SETE_t();
:}
TST #imm, R0 {:  
    load_reg( R_EAX, 0 );
    TEST_imm32_r32( imm, R_EAX );
    SETE_t();
:}
TST.B #imm, @(R0, GBR) {:  
    load_reg( R_EAX, 0);
    load_reg( R_ECX, R_GBR);
    ADD_r32_r32( R_EAX, R_ECX );
    MEM_READ_BYTE( R_ECX, R_EAX );
    TEST_imm8_r8( imm, R_EAX );
    SETE_t();
:}
XOR Rm, Rn {:  
    load_reg( R_EAX, Rm );
    load_reg( R_ECX, Rn );
    XOR_r32_r32( R_EAX, R_ECX );
    store_reg( R_ECX, Rn );
:}
XOR #imm, R0 {:  
    load_reg( R_EAX, 0 );
    XOR_imm32_r32( imm, R_EAX );
    store_reg( R_EAX, 0 );
:}
XOR.B #imm, @(R0, GBR) {:  
    load_reg( R_EAX, 0 );
    load_spreg( R_ECX, R_GBR );
    ADD_r32_r32( R_EAX, R_ECX );
    MEM_READ_BYTE( R_ECX, R_EAX );
    XOR_imm32_r32( imm, R_EAX );
    MEM_WRITE_BYTE( R_ECX, R_EAX );
:}
XTRCT Rm, Rn {:
    load_reg( R_EAX, Rm );
    MOV_r32_r32( R_EAX, R_ECX );
    SHR_imm8_r32( 16, R_EAX );
    SHL_imm8_r32( 16, R_ECX );
    OR_r32_r32( R_EAX, R_ECX );
    store_reg( R_ECX, Rn );
:}

/* Data move instructions */
MOV Rm, Rn {:  
    load_reg( R_EAX, Rm );
    store_reg( R_EAX, Rn );
:}
MOV #imm, Rn {:  
    load_imm32( R_EAX, imm );
    store_reg( R_EAX, Rn );
:}
MOV.B Rm, @Rn {:  
    load_reg( R_EAX, Rm );
    load_reg( R_ECX, Rn );
    MEM_WRITE_BYTE( R_ECX, R_EAX );
:}
MOV.B Rm, @-Rn {:  
    load_reg( R_EAX, Rm );
    load_reg( R_ECX, Rn );
    ADD_imm8s_r32( -1, R_ECX );
    store_reg( R_ECX, Rn );
    MEM_WRITE_BYTE( R_ECX, R_EAX );
:}
MOV.B Rm, @(R0, Rn) {:  
    load_reg( R_EAX, 0 );
    load_reg( R_ECX, Rn );
    ADD_r32_r32( R_EAX, R_ECX );
    load_reg( R_EAX, Rm );
    MEM_WRITE_BYTE( R_ECX, R_EAX );
:}
MOV.B R0, @(disp, GBR) {:  
    load_reg( R_EAX, 0 );
    load_spreg( R_ECX, R_GBR );
    ADD_imm32_r32( disp, R_ECX );
    MEM_WRITE_BYTE( R_ECX, R_EAX );
:}
MOV.B R0, @(disp, Rn) {:  
    load_reg( R_EAX, 0 );
    load_reg( R_ECX, Rn );
    ADD_imm32_r32( disp, R_ECX );
    MEM_WRITE_BYTE( R_ECX, R_EAX );
:}
MOV.B @Rm, Rn {:  
    load_reg( R_ECX, Rm );
    MEM_READ_BYTE( R_ECX, R_EAX );
    store_reg( R_ECX, Rn );
:}
MOV.B @Rm+, Rn {:  
    load_reg( R_ECX, Rm );
    MOV_r32_r32( R_ECX, R_EAX );
    ADD_imm8s_r32( 1, R_EAX );
    store_reg( R_EAX, Rm );
    MEM_READ_BYTE( R_ECX, R_EAX );
    store_reg( R_EAX, Rn );
:}
MOV.B @(R0, Rm), Rn {:  
    load_reg( R_EAX, 0 );
    load_reg( R_ECX, Rm );
    ADD_r32_r32( R_EAX, R_ECX );
    MEM_READ_BYTE( R_ECX, R_EAX );
    store_reg( R_EAX, Rn );
:}
MOV.B @(disp, GBR), R0 {:  
    load_spreg( R_ECX, R_GBR );
    ADD_imm32_r32( disp, R_ECX );
    MEM_READ_BYTE( R_ECX, R_EAX );
    store_reg( R_EAX, 0 );
:}
MOV.B @(disp, Rm), R0 {:  
    load_reg( R_ECX, Rm );
    ADD_imm32_r32( disp, R_ECX );
    MEM_READ_BYTE( R_ECX, R_EAX );
    store_reg( R_EAX, 0 );
:}
MOV.L Rm, @Rn {:
    load_reg( R_EAX, Rm );
    load_reg( R_ECX, Rn );
    check_walign32(R_ECX);
    MEM_WRITE_LONG( R_ECX, R_EAX );
:}
MOV.L Rm, @-Rn {:  
    load_reg( R_EAX, Rm );
    load_reg( R_ECX, Rn );
    check_walign32( R_ECX );
    ADD_imm8s_r32( -4, R_ECX );
    store_reg( R_ECX, Rn );
    MEM_WRITE_LONG( R_ECX, R_EAX );
:}
MOV.L Rm, @(R0, Rn) {:  
    load_reg( R_EAX, 0 );
    load_reg( R_ECX, Rn );
    ADD_r32_r32( R_EAX, R_ECX );
    check_walign32( R_ECX );
    load_reg( R_EAX, Rm );
    MEM_WRITE_LONG( R_ECX, R_EAX );
:}
MOV.L R0, @(disp, GBR) {:  
    load_spreg( R_ECX, R_GBR );
    load_reg( R_EAX, 0 );
    ADD_imm32_r32( disp, R_ECX );
    check_walign32( R_ECX );
    MEM_WRITE_LONG( R_ECX, R_EAX );
:}
MOV.L Rm, @(disp, Rn) {:  
    load_reg( R_ECX, Rn );
    load_reg( R_EAX, Rm );
    ADD_imm32_r32( disp, R_ECX );
    check_walign32( R_ECX );
    MEM_WRITE_LONG( R_ECX, R_EAX );
:}
MOV.L @Rm, Rn {:  
    load_reg( R_ECX, Rm );
    check_ralign32( R_ECX );
    MEM_READ_LONG( R_ECX, R_EAX );
    store_reg( R_EAX, Rn );
:}
MOV.L @Rm+, Rn {:  
    load_reg( R_EAX, Rm );
    check_ralign32( R_EAX );
    MOV_r32_r32( R_EAX, R_ECX );
    ADD_imm8s_r32( 4, R_EAX );
    store_reg( R_EAX, Rm );
    MEM_READ_LONG( R_ECX, R_EAX );
    store_reg( R_EAX, Rn );
:}
MOV.L @(R0, Rm), Rn {:  
    load_reg( R_EAX, 0 );
    load_reg( R_ECX, Rm );
    ADD_r32_r32( R_EAX, R_ECX );
    check_ralign32( R_ECX );
    MEM_READ_LONG( R_ECX, R_EAX );
    store_reg( R_EAX, Rn );
:}
MOV.L @(disp, GBR), R0 {:
    load_spreg( R_ECX, R_GBR );
    ADD_imm32_r32( disp, R_ECX );
    check_ralign32( R_ECX );
    MEM_READ_LONG( R_ECX, R_EAX );
    store_reg( R_EAX, 0 );
:}
MOV.L @(disp, PC), Rn {:  
    if( sh4_x86.in_delay_slot ) {
	SLOTILLEGAL();
    } else {
	load_imm32( R_ECX, (pc & 0xFFFFFFFC) + disp + 4 );
	MEM_READ_LONG( R_ECX, R_EAX );
	store_reg( R_EAX, Rn );
    }
:}
MOV.L @(disp, Rm), Rn {:  
    load_reg( R_ECX, Rm );
    ADD_imm8s_r32( disp, R_ECX );
    check_ralign32( R_ECX );
    MEM_READ_LONG( R_ECX, R_EAX );
    store_reg( R_EAX, Rn );
:}
MOV.W Rm, @Rn {:  
    load_reg( R_ECX, Rn );
    check_walign16( R_ECX );
    load_reg( R_EAX, Rm );
    MEM_WRITE_WORD( R_ECX, R_EAX );
:}
MOV.W Rm, @-Rn {:  
    load_reg( R_ECX, Rn );
    check_walign16( R_ECX );
    load_reg( R_EAX, Rm );
    ADD_imm8s_r32( -2, R_ECX );
    store_reg( R_ECX, Rn );
    MEM_WRITE_WORD( R_ECX, R_EAX );
:}
MOV.W Rm, @(R0, Rn) {:  
    load_reg( R_EAX, 0 );
    load_reg( R_ECX, Rn );
    ADD_r32_r32( R_EAX, R_ECX );
    check_walign16( R_ECX );
    load_reg( R_EAX, Rm );
    MEM_WRITE_WORD( R_ECX, R_EAX );
:}
MOV.W R0, @(disp, GBR) {:  
    load_spreg( R_ECX, R_GBR );
    load_reg( R_EAX, 0 );
    ADD_imm32_r32( disp, R_ECX );
    check_walign16( R_ECX );
    MEM_WRITE_WORD( R_ECX, R_EAX );
:}
MOV.W R0, @(disp, Rn) {:  
    load_reg( R_ECX, Rn );
    load_reg( R_EAX, 0 );
    ADD_imm32_r32( disp, R_ECX );
    check_walign16( R_ECX );
    MEM_WRITE_WORD( R_ECX, R_EAX );
:}
MOV.W @Rm, Rn {:  
    load_reg( R_ECX, Rm );
    check_ralign16( R_ECX );
    MEM_READ_WORD( R_ECX, R_EAX );
    store_reg( R_EAX, Rn );
:}
MOV.W @Rm+, Rn {:  
    load_reg( R_EAX, Rm );
    check_ralign16( R_EAX );
    MOV_r32_r32( R_EAX, R_ECX );
    ADD_imm8s_r32( 2, R_EAX );
    store_reg( R_EAX, Rm );
    MEM_READ_WORD( R_ECX, R_EAX );
    store_reg( R_EAX, Rn );
:}
MOV.W @(R0, Rm), Rn {:  
    load_reg( R_EAX, 0 );
    load_reg( R_ECX, Rm );
    ADD_r32_r32( R_EAX, R_ECX );
    check_ralign16( R_ECX );
    MEM_READ_WORD( R_ECX, R_EAX );
    store_reg( R_EAX, Rn );
:}
MOV.W @(disp, GBR), R0 {:  
    load_spreg( R_ECX, R_GBR );
    ADD_imm32_r32( disp, R_ECX );
    check_ralign16( R_ECX );
    MEM_READ_WORD( R_ECX, R_EAX );
    store_reg( R_EAX, 0 );
:}
MOV.W @(disp, PC), Rn {:  
    if( sh4_x86.in_delay_slot ) {
	SLOTILLEGAL();
    } else {
	load_imm32( R_ECX, pc + disp + 4 );
	MEM_READ_WORD( R_ECX, R_EAX );
	store_reg( R_EAX, Rn );
    }
:}
MOV.W @(disp, Rm), R0 {:  
    load_reg( R_ECX, Rm );
    ADD_imm32_r32( disp, R_ECX );
    check_ralign16( R_ECX );
    MEM_READ_WORD( R_ECX, R_EAX );
    store_reg( R_EAX, 0 );
:}
MOVA @(disp, PC), R0 {:  
    if( sh4_x86.in_delay_slot ) {
	SLOTILLEGAL();
    } else {
	load_imm32( R_ECX, (pc & 0xFFFFFFFC) + disp + 4 );
	store_reg( R_ECX, 0 );
    }
:}
MOVCA.L R0, @Rn {:  
    load_reg( R_EAX, 0 );
    load_reg( R_ECX, Rn );
    check_walign32( R_ECX );
    MEM_WRITE_LONG( R_ECX, R_EAX );
:}

/* Control transfer instructions */
BF disp {:
    if( sh4_x86.in_delay_slot ) {
	SLOTILLEGAL();
    } else {
	load_imm32( R_EDI, pc + 2 );
	CMP_imm8s_sh4r( 0, R_T );
	JNE_rel8( 5, nottaken );
	load_imm32( R_EDI, disp + pc + 4 );
	JMP_TARGET(nottaken);
	INC_r32(R_ESI);
	return 1;
    }
:}
BF/S disp {:
    if( sh4_x86.in_delay_slot ) {
	SLOTILLEGAL();
    } else {
	load_imm32( R_EDI, pc + 2 );
	CMP_imm8s_sh4r( 0, R_T );
	JNE_rel8( 5, nottaken );
	load_imm32( R_EDI, disp + pc + 4 );
	JMP_TARGET(nottaken);
	sh4_x86.in_delay_slot = TRUE;
	INC_r32(R_ESI);
	return 0;
    }
:}
BRA disp {:  
    if( sh4_x86.in_delay_slot ) {
	SLOTILLEGAL();
    } else {
	load_imm32( R_EDI, disp + pc + 4 );
	sh4_x86.in_delay_slot = TRUE;
	INC_r32(R_ESI);
	return 0;
    }
:}
BRAF Rn {:  
    if( sh4_x86.in_delay_slot ) {
	SLOTILLEGAL();
    } else {
	load_reg( R_EDI, Rn );
	ADD_imm32_r32( pc + 4, R_EDI );
	sh4_x86.in_delay_slot = TRUE;
	INC_r32(R_ESI);
	return 0;
    }
:}
BSR disp {:  
    if( sh4_x86.in_delay_slot ) {
	SLOTILLEGAL();
    } else {
	load_imm32( R_EAX, pc + 4 );
	store_spreg( R_EAX, R_PR );
	load_imm32( R_EDI, disp + pc + 4 );
	sh4_x86.in_delay_slot = TRUE;
	INC_r32(R_ESI);
	return 0;
    }
:}
BSRF Rn {:  
    if( sh4_x86.in_delay_slot ) {
	SLOTILLEGAL();
    } else {
	load_imm32( R_EAX, pc + 4 );
	store_spreg( R_EAX, R_PR );
	load_reg( R_EDI, Rn );
	ADD_r32_r32( R_EAX, R_EDI );
	sh4_x86.in_delay_slot = TRUE;
	INC_r32(R_ESI);
	return 0;
    }
:}
BT disp {:
    if( sh4_x86.in_delay_slot ) {
	SLOTILLEGAL();
    } else {
	load_imm32( R_EDI, pc + 2 );
	CMP_imm8s_sh4r( 0, R_T );
	JE_rel8( 5, nottaken );
	load_imm32( R_EDI, disp + pc + 4 );
	JMP_TARGET(nottaken);
	INC_r32(R_ESI);
	return 1;
    }
:}
BT/S disp {:
    if( sh4_x86.in_delay_slot ) {
	SLOTILLEGAL();
    } else {
	load_imm32( R_EDI, pc + 2 );
	CMP_imm8s_sh4r( 0, R_T );
	JE_rel8( 5, nottaken );
	load_imm32( R_EDI, disp + pc + 4 );
	JMP_TARGET(nottaken);
	sh4_x86.in_delay_slot = TRUE;
	INC_r32(R_ESI);
	return 0;
    }
:}
JMP @Rn {:  
    if( sh4_x86.in_delay_slot ) {
	SLOTILLEGAL();
    } else {
	load_reg( R_EDI, Rn );
	sh4_x86.in_delay_slot = TRUE;
	INC_r32(R_ESI);
	return 0;
    }
:}
JSR @Rn {:  
    if( sh4_x86.in_delay_slot ) {
	SLOTILLEGAL();
    } else {
	load_imm32( R_EAX, pc + 4 );
	store_spreg( R_EAX, R_PR );
	load_reg( R_EDI, Rn );
	sh4_x86.in_delay_slot = TRUE;
	INC_r32(R_ESI);
	return 0;
    }
:}
RTE {:  
    check_priv();
    if( sh4_x86.in_delay_slot ) {
	SLOTILLEGAL();
    } else {
	load_spreg( R_EDI, R_PR );
	load_spreg( R_EAX, R_SSR );
	call_func1( sh4_write_sr, R_EAX );
	sh4_x86.in_delay_slot = TRUE;
	sh4_x86.priv_checked = FALSE;
	sh4_x86.fpuen_checked = FALSE;
	INC_r32(R_ESI);
	return 0;
    }
:}
RTS {:  
    if( sh4_x86.in_delay_slot ) {
	SLOTILLEGAL();
    } else {
	load_spreg( R_EDI, R_PR );
	sh4_x86.in_delay_slot = TRUE;
	INC_r32(R_ESI);
	return 0;
    }
:}
TRAPA #imm {:  
    if( sh4_x86.in_delay_slot ) {
	SLOTILLEGAL();
    } else {
	// TODO: Write TRA 
	RAISE_EXCEPTION(EXC_TRAP);
    }
:}
UNDEF {:  
    if( sh4_x86.in_delay_slot ) {
	SLOTILLEGAL();
    } else {
	RAISE_EXCEPTION(EXC_ILLEGAL);
	return 1;
    }
:}

CLRMAC {:  
    XOR_r32_r32(R_EAX, R_EAX);
    store_spreg( R_EAX, R_MACL );
    store_spreg( R_EAX, R_MACH );
:}
CLRS {:
    CLC();
    SETC_sh4r(R_S);
:}
CLRT {:  
    CLC();
    SETC_t();
:}
SETS {:  
    STC();
    SETC_sh4r(R_S);
:}
SETT {:  
    STC();
    SETC_t();
:}

/* Floating point moves */
FMOV FRm, FRn {:  
    /* As horrible as this looks, it's actually covering 5 separate cases:
     * 1. 32-bit fr-to-fr (PR=0)
     * 2. 64-bit dr-to-dr (PR=1, FRm&1 == 0, FRn&1 == 0 )
     * 3. 64-bit dr-to-xd (PR=1, FRm&1 == 0, FRn&1 == 1 )
     * 4. 64-bit xd-to-dr (PR=1, FRm&1 == 1, FRn&1 == 0 )
     * 5. 64-bit xd-to-xd (PR=1, FRm&1 == 1, FRn&1 == 1 )
     */
    check_fpuen();
    load_spreg( R_ECX, R_FPSCR );
    load_fr_bank( R_EDX );
    TEST_imm32_r32( FPSCR_SZ, R_ECX );
    JNE_rel8(8, doublesize);
    load_fr( R_EDX, R_EAX, FRm ); // PR=0 branch
    store_fr( R_EDX, R_EAX, FRn );
    if( FRm&1 ) {
	JMP_rel8(22, end);
	JMP_TARGET(doublesize);
	load_xf_bank( R_ECX ); 
	load_fr( R_ECX, R_EAX, FRm-1 );
	if( FRn&1 ) {
	    load_fr( R_ECX, R_EDX, FRm );
	    store_fr( R_ECX, R_EAX, FRn-1 );
	    store_fr( R_ECX, R_EDX, FRn );
	} else /* FRn&1 == 0 */ {
	    load_fr( R_ECX, R_ECX, FRm );
	    store_fr( R_EDX, R_EAX, FRn-1 );
	    store_fr( R_EDX, R_ECX, FRn );
	}
	JMP_TARGET(end);
    } else /* FRm&1 == 0 */ {
	if( FRn&1 ) {
	    JMP_rel8(22, end);
	    load_xf_bank( R_ECX );
	    load_fr( R_EDX, R_EAX, FRm );
	    load_fr( R_EDX, R_EDX, FRm+1 );
	    store_fr( R_ECX, R_EAX, FRn-1 );
	    store_fr( R_ECX, R_EDX, FRn );
	    JMP_TARGET(end);
	} else /* FRn&1 == 0 */ {
	    JMP_rel8(12, end);
	    load_fr( R_EDX, R_EAX, FRm );
	    load_fr( R_EDX, R_ECX, FRm+1 );
	    store_fr( R_EDX, R_EAX, FRn );
	    store_fr( R_EDX, R_ECX, FRn+1 );
	    JMP_TARGET(end);
	}
    }
:}
FMOV FRm, @Rn {:  
    check_fpuen();
    load_reg( R_EDX, Rn );
    check_walign32( R_EDX );
    load_spreg( R_ECX, R_FPSCR );
    TEST_imm32_r32( FPSCR_SZ, R_ECX );
    JNE_rel8(20, doublesize);
    load_fr_bank( R_ECX );
    load_fr( R_ECX, R_EAX, FRm );
    MEM_WRITE_LONG( R_EDX, R_EAX ); // 12
    if( FRm&1 ) {
	JMP_rel8( 46, end );
	JMP_TARGET(doublesize);
	load_xf_bank( R_ECX );
	load_fr( R_ECX, R_EAX, FRm&0x0E );
	load_fr( R_ECX, R_ECX, FRm|0x01 );
	MEM_WRITE_DOUBLE( R_EDX, R_EAX, R_ECX );
	JMP_TARGET(end);
    } else {
	JMP_rel8( 39, end );
	JMP_TARGET(doublesize);
	load_fr_bank( R_ECX );
	load_fr( R_ECX, R_EAX, FRm&0x0E );
	load_fr( R_ECX, R_ECX, FRm|0x01 );
	MEM_WRITE_DOUBLE( R_EDX, R_EAX, R_ECX );
	JMP_TARGET(end);
    }
:}
FMOV @Rm, FRn {:  
    check_fpuen();
    load_reg( R_EDX, Rm );
    check_ralign32( R_EDX );
    load_spreg( R_ECX, R_FPSCR );
    TEST_imm32_r32( FPSCR_SZ, R_ECX );
    JNE_rel8(19, doublesize);
    MEM_READ_LONG( R_EDX, R_EAX );
    load_fr_bank( R_ECX );
    store_fr( R_ECX, R_EAX, FRn );
    if( FRn&1 ) {
	JMP_rel8(46, end);
	JMP_TARGET(doublesize);
	MEM_READ_DOUBLE( R_EDX, R_EAX, R_EDX );
	load_spreg( R_ECX, R_FPSCR ); // assume read_long clobbered it
	load_xf_bank( R_ECX );
	store_fr( R_ECX, R_EAX, FRn&0x0E );
	store_fr( R_ECX, R_EDX, FRn|0x01 );
	JMP_TARGET(end);
    } else {
	JMP_rel8(36, end);
	JMP_TARGET(doublesize);
	MEM_READ_DOUBLE( R_EDX, R_EAX, R_EDX );
	load_fr_bank( R_ECX );
	store_fr( R_ECX, R_EAX, FRn&0x0E );
	store_fr( R_ECX, R_EDX, FRn|0x01 );
	JMP_TARGET(end);
    }
:}
FMOV FRm, @-Rn {:  
    check_fpuen();
    load_reg( R_EDX, Rn );
    check_walign32( R_EDX );
    load_spreg( R_ECX, R_FPSCR );
    TEST_imm32_r32( FPSCR_SZ, R_ECX );
    JNE_rel8(26, doublesize);
    load_fr_bank( R_ECX );
    load_fr( R_ECX, R_EAX, FRm );
    ADD_imm8s_r32(-4,R_EDX);
    store_reg( R_EDX, Rn );
    MEM_WRITE_LONG( R_EDX, R_EAX ); // 12
    if( FRm&1 ) {
	JMP_rel8( 52, end );
	JMP_TARGET(doublesize);
	load_xf_bank( R_ECX );
	load_fr( R_ECX, R_EAX, FRm&0x0E );
	load_fr( R_ECX, R_ECX, FRm|0x01 );
	ADD_imm8s_r32(-8,R_EDX);
	store_reg( R_EDX, Rn );
	MEM_WRITE_DOUBLE( R_EDX, R_EAX, R_ECX );
	JMP_TARGET(end);
    } else {
	JMP_rel8( 45, end );
	JMP_TARGET(doublesize);
	load_fr_bank( R_ECX );
	load_fr( R_ECX, R_EAX, FRm&0x0E );
	load_fr( R_ECX, R_ECX, FRm|0x01 );
	ADD_imm8s_r32(-8,R_EDX);
	store_reg( R_EDX, Rn );
	MEM_WRITE_DOUBLE( R_EDX, R_EAX, R_ECX );
	JMP_TARGET(end);
    }
:}
FMOV @Rm+, FRn {:  
    check_fpuen();
    load_reg( R_EDX, Rm );
    check_ralign32( R_EDX );
    MOV_r32_r32( R_EDX, R_EAX );
    load_spreg( R_ECX, R_FPSCR );
    TEST_imm32_r32( FPSCR_SZ, R_ECX );
    JNE_rel8(25, doublesize);
    ADD_imm8s_r32( 4, R_EAX );
    store_reg( R_EAX, Rm );
    MEM_READ_LONG( R_EDX, R_EAX );
    load_fr_bank( R_ECX );
    store_fr( R_ECX, R_EAX, FRn );
    if( FRn&1 ) {
	JMP_rel8(52, end);
	JMP_TARGET(doublesize);
	ADD_imm8s_r32( 8, R_EAX );
	store_reg(R_EAX, Rm);
	MEM_READ_DOUBLE( R_EDX, R_EAX, R_EDX );
	load_spreg( R_ECX, R_FPSCR ); // assume read_long clobbered it
	load_xf_bank( R_ECX );
	store_fr( R_ECX, R_EAX, FRn&0x0E );
	store_fr( R_ECX, R_EDX, FRn|0x01 );
	JMP_TARGET(end);
    } else {
	JMP_rel8(42, end);
	ADD_imm8s_r32( 8, R_EAX );
	store_reg(R_EAX, Rm);
	MEM_READ_DOUBLE( R_EDX, R_EAX, R_EDX );
	load_fr_bank( R_ECX );
	store_fr( R_ECX, R_EAX, FRn&0x0E );
	store_fr( R_ECX, R_EDX, FRn|0x01 );
	JMP_TARGET(end);
    }
:}
FMOV FRm, @(R0, Rn) {:  
    check_fpuen();
    load_reg( R_EDX, Rn );
    ADD_sh4r_r32( REG_OFFSET(r[0]), R_EDX );
    check_walign32( R_EDX );
    load_spreg( R_ECX, R_FPSCR );
    TEST_imm32_r32( FPSCR_SZ, R_ECX );
    JNE_rel8(20, doublesize);
    load_fr_bank( R_ECX );
    load_fr( R_ECX, R_EAX, FRm );
    MEM_WRITE_LONG( R_EDX, R_EAX ); // 12
    if( FRm&1 ) {
	JMP_rel8( 46, end );
	JMP_TARGET(doublesize);
	load_xf_bank( R_ECX );
	load_fr( R_ECX, R_EAX, FRm&0x0E );
	load_fr( R_ECX, R_ECX, FRm|0x01 );
	MEM_WRITE_DOUBLE( R_EDX, R_EAX, R_ECX );
	JMP_TARGET(end);
    } else {
	JMP_rel8( 39, end );
	JMP_TARGET(doublesize);
	load_fr_bank( R_ECX );
	load_fr( R_ECX, R_EAX, FRm&0x0E );
	load_fr( R_ECX, R_ECX, FRm|0x01 );
	MEM_WRITE_DOUBLE( R_EDX, R_EAX, R_ECX );
	JMP_TARGET(end);
    }
:}
FMOV @(R0, Rm), FRn {:  
    check_fpuen();
    load_reg( R_EDX, Rm );
    ADD_sh4r_r32( REG_OFFSET(r[0]), R_EDX );
    check_ralign32( R_EDX );
    load_spreg( R_ECX, R_FPSCR );
    TEST_imm32_r32( FPSCR_SZ, R_ECX );
    JNE_rel8(19, doublesize);
    MEM_READ_LONG( R_EDX, R_EAX );
    load_fr_bank( R_ECX );
    store_fr( R_ECX, R_EAX, FRn );
    if( FRn&1 ) {
	JMP_rel8(46, end);
	JMP_TARGET(doublesize);
	MEM_READ_DOUBLE( R_EDX, R_EAX, R_EDX );
	load_spreg( R_ECX, R_FPSCR ); // assume read_long clobbered it
	load_xf_bank( R_ECX );
	store_fr( R_ECX, R_EAX, FRn&0x0E );
	store_fr( R_ECX, R_EDX, FRn|0x01 );
	JMP_TARGET(end);
    } else {
	JMP_rel8(36, end);
	JMP_TARGET(doublesize);
	MEM_READ_DOUBLE( R_EDX, R_EAX, R_EDX );
	load_fr_bank( R_ECX );
	store_fr( R_ECX, R_EAX, FRn&0x0E );
	store_fr( R_ECX, R_EDX, FRn|0x01 );
	JMP_TARGET(end);
    }
:}
FLDI0 FRn {:  /* IFF PR=0 */
    check_fpuen();
    load_spreg( R_ECX, R_FPSCR );
    TEST_imm32_r32( FPSCR_PR, R_ECX );
    JNE_rel8(8, end);
    XOR_r32_r32( R_EAX, R_EAX );
    load_spreg( R_ECX, REG_OFFSET(fr_bank) );
    store_fr( R_ECX, R_EAX, FRn );
    JMP_TARGET(end);
:}
FLDI1 FRn {:  /* IFF PR=0 */
    check_fpuen();
    load_spreg( R_ECX, R_FPSCR );
    TEST_imm32_r32( FPSCR_PR, R_ECX );
    JNE_rel8(11, end);
    load_imm32(R_EAX, 0x3F800000);
    load_spreg( R_ECX, REG_OFFSET(fr_bank) );
    store_fr( R_ECX, R_EAX, FRn );
    JMP_TARGET(end);
:}

FLOAT FPUL, FRn {:  
    check_fpuen();
    load_spreg( R_ECX, R_FPSCR );
    load_spreg(R_EDX, REG_OFFSET(fr_bank));
    FILD_sh4r(R_FPUL);
    TEST_imm32_r32( FPSCR_PR, R_ECX );
    JNE_rel8(5, doubleprec);
    pop_fr( R_EDX, FRn );
    JMP_rel8(3, end);
    JMP_TARGET(doubleprec);
    pop_dr( R_EDX, FRn );
    JMP_TARGET(end);
:}
FTRC FRm, FPUL {:  
    check_fpuen();
    // TODO
:}
FLDS FRm, FPUL {:  
    check_fpuen();
    load_fr_bank( R_ECX );
    load_fr( R_ECX, R_EAX, FRm );
    store_spreg( R_EAX, R_FPUL );
:}
FSTS FPUL, FRn {:  
    check_fpuen();
    load_fr_bank( R_ECX );
    load_spreg( R_EAX, R_FPUL );
    store_fr( R_ECX, R_EAX, FRn );
:}
FCNVDS FRm, FPUL {:  
    check_fpuen();
    load_spreg( R_ECX, R_FPSCR );
    TEST_imm32_r32( FPSCR_PR, R_ECX );
    JE_rel8(9, end); // only when PR=1
    load_fr_bank( R_ECX );
    push_dr( R_ECX, FRm );
    pop_fpul();
    JMP_TARGET(end);
:}
FCNVSD FPUL, FRn {:  
    check_fpuen();
    check_fpuen();
    load_spreg( R_ECX, R_FPSCR );
    TEST_imm32_r32( FPSCR_PR, R_ECX );
    JE_rel8(9, end); // only when PR=1
    load_fr_bank( R_ECX );
    push_fpul();
    pop_dr( R_ECX, FRn );
    JMP_TARGET(end);
:}

/* Floating point instructions */
FABS FRn {:  
    check_fpuen();
    load_spreg( R_ECX, R_FPSCR );
    load_fr_bank( R_EDX );
    TEST_imm32_r32( FPSCR_PR, R_ECX );
    JNE_rel8(10, doubleprec);
    push_fr(R_EDX, FRn); // 3
    FABS_st0(); // 2
    pop_fr( R_EDX, FRn); //3
    JMP_rel8(8,end); // 2
    JMP_TARGET(doubleprec);
    push_dr(R_EDX, FRn);
    FABS_st0();
    pop_dr(R_EDX, FRn);
    JMP_TARGET(end);
:}
FADD FRm, FRn {:  
    check_fpuen();
    load_spreg( R_ECX, R_FPSCR );
    TEST_imm32_r32( FPSCR_PR, R_ECX );
    load_fr_bank( R_EDX );
    JNE_rel8(13,doubleprec);
    push_fr(R_EDX, FRm);
    push_fr(R_EDX, FRn);
    FADDP_st(1);
    pop_fr(R_EDX, FRn);
    JMP_rel8(11,end);
    JMP_TARGET(doubleprec);
    push_dr(R_EDX, FRm);
    push_dr(R_EDX, FRn);
    FADDP_st(1);
    pop_dr(R_EDX, FRn);
    JMP_TARGET(end);
:}
FDIV FRm, FRn {:  
    check_fpuen();
    load_spreg( R_ECX, R_FPSCR );
    TEST_imm32_r32( FPSCR_PR, R_ECX );
    load_fr_bank( R_EDX );
    JNE_rel8(13, doubleprec);
    push_fr(R_EDX, FRn);
    push_fr(R_EDX, FRm);
    FDIVP_st(1);
    pop_fr(R_EDX, FRn);
    JMP_rel8(11, end);
    JMP_TARGET(doubleprec);
    push_dr(R_EDX, FRn);
    push_dr(R_EDX, FRm);
    FDIVP_st(1);
    pop_dr(R_EDX, FRn);
    JMP_TARGET(end);
:}
FMAC FR0, FRm, FRn {:  
    check_fpuen();
    load_spreg( R_ECX, R_FPSCR );
    load_spreg( R_EDX, REG_OFFSET(fr_bank));
    TEST_imm32_r32( FPSCR_PR, R_ECX );
    JNE_rel8(18, doubleprec);
    push_fr( R_EDX, 0 );
    push_fr( R_EDX, FRm );
    FMULP_st(1);
    push_fr( R_EDX, FRn );
    FADDP_st(1);
    pop_fr( R_EDX, FRn );
    JMP_rel8(16, end);
    JMP_TARGET(doubleprec);
    push_dr( R_EDX, 0 );
    push_dr( R_EDX, FRm );
    FMULP_st(1);
    push_dr( R_EDX, FRn );
    FADDP_st(1);
    pop_dr( R_EDX, FRn );
    JMP_TARGET(end);
:}

FMUL FRm, FRn {:  
    check_fpuen();
    load_spreg( R_ECX, R_FPSCR );
    TEST_imm32_r32( FPSCR_PR, R_ECX );
    load_fr_bank( R_EDX );
    JNE_rel8(13, doubleprec);
    push_fr(R_EDX, FRm);
    push_fr(R_EDX, FRn);
    FMULP_st(1);
    pop_fr(R_EDX, FRn);
    JMP_rel8(11, end);
    JMP_TARGET(doubleprec);
    push_dr(R_EDX, FRm);
    push_dr(R_EDX, FRn);
    FMULP_st(1);
    pop_dr(R_EDX, FRn);
    JMP_TARGET(end);
:}
FNEG FRn {:  
    check_fpuen();
    load_spreg( R_ECX, R_FPSCR );
    TEST_imm32_r32( FPSCR_PR, R_ECX );
    load_fr_bank( R_EDX );
    JNE_rel8(10, doubleprec);
    push_fr(R_EDX, FRn);
    FCHS_st0();
    pop_fr(R_EDX, FRn);
    JMP_rel8(8, end);
    JMP_TARGET(doubleprec);
    push_dr(R_EDX, FRn);
    FCHS_st0();
    pop_dr(R_EDX, FRn);
    JMP_TARGET(end);
:}
FSRRA FRn {:  
    check_fpuen();
    load_spreg( R_ECX, R_FPSCR );
    TEST_imm32_r32( FPSCR_PR, R_ECX );
    load_fr_bank( R_EDX );
    JNE_rel8(12, end); // PR=0 only
    FLD1_st0();
    push_fr(R_EDX, FRn);
    FSQRT_st0();
    FDIVP_st(1);
    pop_fr(R_EDX, FRn);
    JMP_TARGET(end);
:}
FSQRT FRn {:  
    check_fpuen();
    load_spreg( R_ECX, R_FPSCR );
    TEST_imm32_r32( FPSCR_PR, R_ECX );
    load_fr_bank( R_EDX );
    JNE_rel8(10, doubleprec);
    push_fr(R_EDX, FRn);
    FSQRT_st0();
    pop_fr(R_EDX, FRn);
    JMP_rel8(8, end);
    JMP_TARGET(doubleprec);
    push_dr(R_EDX, FRn);
    FSQRT_st0();
    pop_dr(R_EDX, FRn);
    JMP_TARGET(end);
:}
FSUB FRm, FRn {:  
    check_fpuen();
    load_spreg( R_ECX, R_FPSCR );
    TEST_imm32_r32( FPSCR_PR, R_ECX );
    load_fr_bank( R_EDX );
    JNE_rel8(13, doubleprec);
    push_fr(R_EDX, FRn);
    push_fr(R_EDX, FRm);
    FMULP_st(1);
    pop_fr(R_EDX, FRn);
    JMP_rel8(11, end);
    JMP_TARGET(doubleprec);
    push_dr(R_EDX, FRn);
    push_dr(R_EDX, FRm);
    FMULP_st(1);
    pop_dr(R_EDX, FRn);
    JMP_TARGET(end);
:}

FCMP/EQ FRm, FRn {:  
    check_fpuen();
    load_spreg( R_ECX, R_FPSCR );
    TEST_imm32_r32( FPSCR_PR, R_ECX );
    load_fr_bank( R_EDX );
    JNE_rel8(8, doubleprec);
    push_fr(R_EDX, FRm);
    push_fr(R_EDX, FRn);
    JMP_rel8(6, end);
    JMP_TARGET(doubleprec);
    push_dr(R_EDX, FRm);
    push_dr(R_EDX, FRn);
    JMP_TARGET(end);
    FCOMIP_st(1);
    SETE_t();
    FPOP_st();
:}
FCMP/GT FRm, FRn {:  
    check_fpuen();
    load_spreg( R_ECX, R_FPSCR );
    TEST_imm32_r32( FPSCR_PR, R_ECX );
    load_fr_bank( R_EDX );
    JNE_rel8(8, doubleprec);
    push_fr(R_EDX, FRm);
    push_fr(R_EDX, FRn);
    JMP_rel8(6, end);
    JMP_TARGET(doubleprec);
    push_dr(R_EDX, FRm);
    push_dr(R_EDX, FRn);
    JMP_TARGET(end);
    FCOMIP_st(1);
    SETA_t();
    FPOP_st();
:}

FSCA FPUL, FRn {:  
    check_fpuen();
:}
FIPR FVm, FVn {:  
    check_fpuen();
:}
FTRV XMTRX, FVn {:  
    check_fpuen();
:}

FRCHG {:  
    check_fpuen();
    load_spreg( R_ECX, R_FPSCR );
    XOR_imm32_r32( FPSCR_FR, R_ECX );
    store_spreg( R_ECX, R_FPSCR );
    
:}
FSCHG {:  
    check_fpuen();
    load_spreg( R_ECX, R_FPSCR );
    XOR_imm32_r32( FPSCR_SZ, R_ECX );
    store_spreg( R_ECX, R_FPSCR );
:}

/* Processor control instructions */
LDC Rm, SR {:
    load_reg( R_EAX, Rm );
    call_func1( sh4_write_sr, R_EAX );
    sh4_x86.priv_checked = FALSE;
    sh4_x86.fpuen_checked = FALSE;
:}
LDC Rm, GBR {: 
    load_reg( R_EAX, Rm );
    store_spreg( R_EAX, R_GBR );
:}
LDC Rm, VBR {:  
    load_reg( R_EAX, Rm );
    store_spreg( R_EAX, R_VBR );
:}
LDC Rm, SSR {:  
    load_reg( R_EAX, Rm );
    store_spreg( R_EAX, R_SSR );
:}
LDC Rm, SGR {:  
    load_reg( R_EAX, Rm );
    store_spreg( R_EAX, R_SGR );
:}
LDC Rm, SPC {:  
    load_reg( R_EAX, Rm );
    store_spreg( R_EAX, R_SPC );
:}
LDC Rm, DBR {:  
    load_reg( R_EAX, Rm );
    store_spreg( R_EAX, R_DBR );
:}
LDC Rm, Rn_BANK {:  
    load_reg( R_EAX, Rm );
    store_spreg( R_EAX, REG_OFFSET(r_bank[Rn_BANK]) );
:}
LDC.L @Rm+, GBR {:  
    load_reg( R_EAX, Rm );
    MOV_r32_r32( R_EAX, R_ECX );
    ADD_imm8s_r32( 4, R_EAX );
    store_reg( R_EAX, Rm );
    MEM_READ_LONG( R_ECX, R_EAX );
    store_spreg( R_EAX, R_GBR );
:}
LDC.L @Rm+, SR {:
    load_reg( R_EAX, Rm );
    MOV_r32_r32( R_EAX, R_ECX );
    ADD_imm8s_r32( 4, R_EAX );
    store_reg( R_EAX, Rm );
    MEM_READ_LONG( R_ECX, R_EAX );
    call_func1( sh4_write_sr, R_EAX );
    sh4_x86.priv_checked = FALSE;
    sh4_x86.fpuen_checked = FALSE;
:}
LDC.L @Rm+, VBR {:  
    load_reg( R_EAX, Rm );
    MOV_r32_r32( R_EAX, R_ECX );
    ADD_imm8s_r32( 4, R_EAX );
    store_reg( R_EAX, Rm );
    MEM_READ_LONG( R_ECX, R_EAX );
    store_spreg( R_EAX, R_VBR );
:}
LDC.L @Rm+, SSR {:
    load_reg( R_EAX, Rm );
    MOV_r32_r32( R_EAX, R_ECX );
    ADD_imm8s_r32( 4, R_EAX );
    store_reg( R_EAX, Rm );
    MEM_READ_LONG( R_ECX, R_EAX );
    store_spreg( R_EAX, R_SSR );
:}
LDC.L @Rm+, SGR {:  
    load_reg( R_EAX, Rm );
    MOV_r32_r32( R_EAX, R_ECX );
    ADD_imm8s_r32( 4, R_EAX );
    store_reg( R_EAX, Rm );
    MEM_READ_LONG( R_ECX, R_EAX );
    store_spreg( R_EAX, R_SGR );
:}
LDC.L @Rm+, SPC {:  
    load_reg( R_EAX, Rm );
    MOV_r32_r32( R_EAX, R_ECX );
    ADD_imm8s_r32( 4, R_EAX );
    store_reg( R_EAX, Rm );
    MEM_READ_LONG( R_ECX, R_EAX );
    store_spreg( R_EAX, R_SPC );
:}
LDC.L @Rm+, DBR {:  
    load_reg( R_EAX, Rm );
    MOV_r32_r32( R_EAX, R_ECX );
    ADD_imm8s_r32( 4, R_EAX );
    store_reg( R_EAX, Rm );
    MEM_READ_LONG( R_ECX, R_EAX );
    store_spreg( R_EAX, R_DBR );
:}
LDC.L @Rm+, Rn_BANK {:  
    load_reg( R_EAX, Rm );
    MOV_r32_r32( R_EAX, R_ECX );
    ADD_imm8s_r32( 4, R_EAX );
    store_reg( R_EAX, Rm );
    MEM_READ_LONG( R_ECX, R_EAX );
    store_spreg( R_EAX, REG_OFFSET(r_bank[Rn_BANK]) );
:}
LDS Rm, FPSCR {:  
    load_reg( R_EAX, Rm );
    store_spreg( R_EAX, R_FPSCR );
:}
LDS.L @Rm+, FPSCR {:  
    load_reg( R_EAX, Rm );
    MOV_r32_r32( R_EAX, R_ECX );
    ADD_imm8s_r32( 4, R_EAX );
    store_reg( R_EAX, Rm );
    MEM_READ_LONG( R_ECX, R_EAX );
    store_spreg( R_EAX, R_FPSCR );
:}
LDS Rm, FPUL {:  
    load_reg( R_EAX, Rm );
    store_spreg( R_EAX, R_FPUL );
:}
LDS.L @Rm+, FPUL {:  
    load_reg( R_EAX, Rm );
    MOV_r32_r32( R_EAX, R_ECX );
    ADD_imm8s_r32( 4, R_EAX );
    store_reg( R_EAX, Rm );
    MEM_READ_LONG( R_ECX, R_EAX );
    store_spreg( R_EAX, R_FPUL );
:}
LDS Rm, MACH {: 
    load_reg( R_EAX, Rm );
    store_spreg( R_EAX, R_MACH );
:}
LDS.L @Rm+, MACH {:  
    load_reg( R_EAX, Rm );
    MOV_r32_r32( R_EAX, R_ECX );
    ADD_imm8s_r32( 4, R_EAX );
    store_reg( R_EAX, Rm );
    MEM_READ_LONG( R_ECX, R_EAX );
    store_spreg( R_EAX, R_MACH );
:}
LDS Rm, MACL {:  
    load_reg( R_EAX, Rm );
    store_spreg( R_EAX, R_MACL );
:}
LDS.L @Rm+, MACL {:  
    load_reg( R_EAX, Rm );
    MOV_r32_r32( R_EAX, R_ECX );
    ADD_imm8s_r32( 4, R_EAX );
    store_reg( R_EAX, Rm );
    MEM_READ_LONG( R_ECX, R_EAX );
    store_spreg( R_EAX, R_MACL );
:}
LDS Rm, PR {:  
    load_reg( R_EAX, Rm );
    store_spreg( R_EAX, R_PR );
:}
LDS.L @Rm+, PR {:  
    load_reg( R_EAX, Rm );
    MOV_r32_r32( R_EAX, R_ECX );
    ADD_imm8s_r32( 4, R_EAX );
    store_reg( R_EAX, Rm );
    MEM_READ_LONG( R_ECX, R_EAX );
    store_spreg( R_EAX, R_PR );
:}
LDTLB {:  :}
OCBI @Rn {:  :}
OCBP @Rn {:  :}
OCBWB @Rn {:  :}
PREF @Rn {:
    load_reg( R_EAX, Rn );
    PUSH_r32( R_EAX );
    AND_imm32_r32( 0xFC000000, R_EAX );
    CMP_imm32_r32( 0xE0000000, R_EAX );
    JNE_rel8(7, end);
    call_func0( sh4_flush_store_queue );
    JMP_TARGET(end);
    ADD_imm8s_r32( 4, R_ESP );
:}
 SLEEP {: /* TODO */ :}
 STC SR, Rn {:
     call_func0(sh4_read_sr);
     store_reg( R_EAX, Rn );
:}
STC GBR, Rn {:  
    load_spreg( R_EAX, R_GBR );
    store_reg( R_EAX, Rn );
:}
STC VBR, Rn {:  
    load_spreg( R_EAX, R_VBR );
    store_reg( R_EAX, Rn );
:}
STC SSR, Rn {:  
    load_spreg( R_EAX, R_SSR );
    store_reg( R_EAX, Rn );
:}
STC SPC, Rn {:  
    load_spreg( R_EAX, R_SPC );
    store_reg( R_EAX, Rn );
:}
STC SGR, Rn {:  
    load_spreg( R_EAX, R_SGR );
    store_reg( R_EAX, Rn );
:}
STC DBR, Rn {:  
    load_spreg( R_EAX, R_DBR );
    store_reg( R_EAX, Rn );
:}
STC Rm_BANK, Rn {:
    load_spreg( R_EAX, REG_OFFSET(r_bank[Rm_BANK]) );
    store_reg( R_EAX, Rn );
:}
STC.L SR, @-Rn {:
    load_reg( R_ECX, Rn );
    ADD_imm8s_r32( -4, R_ECX );
    store_reg( R_ECX, Rn );
    call_func0( sh4_read_sr );
    MEM_WRITE_LONG( R_ECX, R_EAX );
:}
STC.L VBR, @-Rn {:  
    load_reg( R_ECX, Rn );
    ADD_imm8s_r32( -4, R_ECX );
    store_reg( R_ECX, Rn );
    load_spreg( R_EAX, R_VBR );
    MEM_WRITE_LONG( R_ECX, R_EAX );
:}
STC.L SSR, @-Rn {:  
    load_reg( R_ECX, Rn );
    ADD_imm8s_r32( -4, R_ECX );
    store_reg( R_ECX, Rn );
    load_spreg( R_EAX, R_SSR );
    MEM_WRITE_LONG( R_ECX, R_EAX );
:}
STC.L SPC, @-Rn {:  
    load_reg( R_ECX, Rn );
    ADD_imm8s_r32( -4, R_ECX );
    store_reg( R_ECX, Rn );
    load_spreg( R_EAX, R_SPC );
    MEM_WRITE_LONG( R_ECX, R_EAX );
:}
STC.L SGR, @-Rn {:  
    load_reg( R_ECX, Rn );
    ADD_imm8s_r32( -4, R_ECX );
    store_reg( R_ECX, Rn );
    load_spreg( R_EAX, R_SGR );
    MEM_WRITE_LONG( R_ECX, R_EAX );
:}
STC.L DBR, @-Rn {:  
    load_reg( R_ECX, Rn );
    ADD_imm8s_r32( -4, R_ECX );
    store_reg( R_ECX, Rn );
    load_spreg( R_EAX, R_DBR );
    MEM_WRITE_LONG( R_ECX, R_EAX );
:}
STC.L Rm_BANK, @-Rn {:  
    load_reg( R_ECX, Rn );
    ADD_imm8s_r32( -4, R_ECX );
    store_reg( R_ECX, Rn );
    load_spreg( R_EAX, REG_OFFSET(r_bank[Rm_BANK]) );
    MEM_WRITE_LONG( R_ECX, R_EAX );
:}
STC.L GBR, @-Rn {:  
    load_reg( R_ECX, Rn );
    ADD_imm8s_r32( -4, R_ECX );
    store_reg( R_ECX, Rn );
    load_spreg( R_EAX, R_GBR );
    MEM_WRITE_LONG( R_ECX, R_EAX );
:}
STS FPSCR, Rn {:  
    load_spreg( R_EAX, R_FPSCR );
    store_reg( R_EAX, Rn );
:}
STS.L FPSCR, @-Rn {:  
    load_reg( R_ECX, Rn );
    ADD_imm8s_r32( -4, R_ECX );
    store_reg( R_ECX, Rn );
    load_spreg( R_EAX, R_FPSCR );
    MEM_WRITE_LONG( R_ECX, R_EAX );
:}
STS FPUL, Rn {:  
    load_spreg( R_EAX, R_FPUL );
    store_reg( R_EAX, Rn );
:}
STS.L FPUL, @-Rn {:  
    load_reg( R_ECX, Rn );
    ADD_imm8s_r32( -4, R_ECX );
    store_reg( R_ECX, Rn );
    load_spreg( R_EAX, R_FPUL );
    MEM_WRITE_LONG( R_ECX, R_EAX );
:}
STS MACH, Rn {:  
    load_spreg( R_EAX, R_MACH );
    store_reg( R_EAX, Rn );
:}
STS.L MACH, @-Rn {:  
    load_reg( R_ECX, Rn );
    ADD_imm8s_r32( -4, R_ECX );
    store_reg( R_ECX, Rn );
    load_spreg( R_EAX, R_MACH );
    MEM_WRITE_LONG( R_ECX, R_EAX );
:}
STS MACL, Rn {:  
    load_spreg( R_EAX, R_MACL );
    store_reg( R_EAX, Rn );
:}
STS.L MACL, @-Rn {:  
    load_reg( R_ECX, Rn );
    ADD_imm8s_r32( -4, R_ECX );
    store_reg( R_ECX, Rn );
    load_spreg( R_EAX, R_MACL );
    MEM_WRITE_LONG( R_ECX, R_EAX );
:}
STS PR, Rn {:  
    load_spreg( R_EAX, R_PR );
    store_reg( R_EAX, Rn );
:}
STS.L PR, @-Rn {:  
    load_reg( R_ECX, Rn );
    ADD_imm8s_r32( -4, R_ECX );
    store_reg( R_ECX, Rn );
    load_spreg( R_EAX, R_PR );
    MEM_WRITE_LONG( R_ECX, R_EAX );
:}

NOP {: /* Do nothing. Well, we could emit an 0x90, but what would really be the point? */ :}
%%
    INC_r32(R_ESI);
    if( sh4_x86.in_delay_slot ) {
	sh4_x86.in_delay_slot = FALSE;
	return 1;
    }
    return 0;
}
